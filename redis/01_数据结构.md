# 数据结构

Redis为用户提供了字符串、散列、列表、集合、有序集合、HyperLongLog、位图、流、地理坐标等一系列丰富的数据结构，每种数据结构都适用于解决特定的问题。在有需要的时候，用户还可以通过事务、Lua脚本、模块等特性，扩展已有数据结构的功能，甚至从零实现自己专属的数据结构。

## 字符串 String

键值对类型，设置相同key的值会被覆盖。

### 应用场景

#### 1. 分布式锁

使用setnx命令，当key不存在时，设值为1并返回，当key已存在时，不设值并返回0。可以利用这个原子性操作的特性，返回1表示获得锁，返回0表示没有获得锁。应用场景如：为了保证定时任务的高可用，往往会同时部署多个具备相同定时任务的服务，多个任务同时竞争一个分布式锁，获得锁后执行对应的定时任务，执行完毕后通过del释放锁。为了防止命令操作失败而导致锁一直未释放，可以在取得锁的时候未锁设定一个自动过期时间expire。

#### 2. 计数器

例如网站的访客数量、用户执行某个操作的次数，微博的转发数，点赞数等，使用incr和decr命令可以很容易对key中存储的数字进行加减操作。

#### 3. 限速器

例如限制一个IP对网站的访问频率

## 散列 Hash

Redis的散列会将一个键和一个散列在数据库里面关联起来，用户可以在散列里面为任意多个字段设置值。散列适合用来存储对象数据，例如存储一篇文章的信息：

~~~shell
				key 											field 								value
+------------------+       +------------------+
| "article::10086" | ————> |      "title"     | ————> "greeting"
+------------------+	   +------------------+
                           |     "content"    | ————> "hello world"
			   +------------------+
			   |      "author"    | ————> "peter"
			   +------------------+
			   |   "created_at"   | ————> "1442744762.631885"
			   +------------------+

~~~

### 应用场景

#### 1. 实现短网址生成程序

短网址的原理是短网址ID与目标网址之间建立映射关系，用户在访问短网址时，根据短网址ID自动转换为目标网址进行访问：

~~~shell   											    			           key	                          field                   value
+-----------------------+       +-----------+
| "ShortyURL::url_hash" |————>  | "RqEEZ8n" | ————> "http://redisdoc.com/geo/index.html"
+-----------------------+	+-----------+									 			                | "RUwtQBX" | ————> "http://item.jd.com/11791607.html"
				+-----------+
				| "RqjpE5I" | ————> "http://redisguide.com"
				+-----------+
~~~

#### 2. 购物车

~~~shell
	 key 	  field  value
	用户id 	商品id	商品数量
~~~

这样可以根据用户id查询用户购物车中的所有商品信息，实现 *全选* 的功能，同时，可以通过用户id和商品id查询用户对应商品的下单数量等功能。

#### 3. 存储对象类型的数据

对象包括三个部分内容：对象id、属性、值，刚好可以对应散列的key、field、value，当一个对象的某个属性频繁修改时，使用json的序列化与反序列化的开销比较大，可以使用redis的散列，只需要修改属性对应的值即可，比如商品的价格、销量、关注数、评价数等可能经常变化的属性。

## 列表 List

Redis中的列表是一个双向无环链表。

其中有两种编码结构：ziplist和linkedlist

当数据量较小时，使用ziplist，反之使用linkedlist进行编码。

列表中的”左“对应链表头，”右“对应链表尾。

### 应用场景

#### 1. 先进先出队列

例如一个秒杀活动，将用户的购买操作都放到一个先进先出队列里面，然后以队列的方式处理用户的购买操作。如果使用事务或者锁去实现秒杀程序，那么会因为锁和事务的重试特性导致性能低下，并且由于重试的存在，成功购买商品的用户可能并不是最早执行购买操作的用户，从而丧失公平性。

#### 2. 带有阻塞功能的消息队列

例如使用邮箱注册账号时，一般需要进行邮件验证才能注册成功，如果直接顺序执行的话，由于发邮件的过程耗时而且可能存在发送失败的可能，会导致用户获取注册结果等待的时间较长，这时可以使用Redis的list存储待发邮件的列表，用户提交注册信息后，将待发邮件任务发送到任务队列中，直接向用户反馈注册结果。使用rpush入队，blpop阻塞式出队。

#### 3. 排行榜

lrange命令可以分页查看队列中的数据，可以将每隔一段时间计算一次的排行榜存储在list类型中，如手机日销榜、学校月考成绩榜等。这种排行榜模型只适用于定时排序的模型，实时排行榜还是需要使用sorted set

> 既然有sorted set类型，也能实现list的功能，为何不是全部使用sorted set来实现排行榜的功能？
>
> 由于sorted set类型占用的内存空间是list类型的数倍之多，对于列表数量不多，可以使用sorted set类型来实现。对于类型丰富，数据庞大的榜单，还是用list比较合理。

## 集合 Set

Redis的集合键允许用户将任意多个各不相同的元素存储到集合里面，这些元素既可以是文本数据，也可以是二进制数据。

集合对象的编码可以是intset或者hashtable

intset用于存储整数集合

hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个集合中的字符串对象，而字典的值则全部被设置为NULL。

~~~shell
redis> SADD Dfruits "apple" "banana" "cherry"
~~~

对应数据在hashtable中的存储结构为：

~~~shell
+--------------------+   		+--------------------+    
|     redisObject    |	      —————————>|        dict        |
+--------------------+        |		+--------------------+
|       type         |        |		|    StringObject    | ——————> NULL
|      REDIS_SET     |        |		|	"cherry"     | 
+--------------------+        |	        +--------------------+
|      encoding      |        |         |    StringObject    | ——————> NULL
| REDIS_ENCODING_HT  |        |         |	"apple"      |
+--------------------+	      |         +--------------------+
|         ptr        |————————          |    StringObject    | ——————> NULL
+--------------------+                  |      "banana"      |
|         ...        |                  +--------------------+
+--------------------+
~~~

### 应用场景

#### 1. 社交关系

如微博中某个用户的所有关注人，所有粉丝，可以分别存储在两个集合中，同时，通过求交集，并集，差集等功能，可以方便地实现如共同关注、共同好友、二度好友、推荐关注等功能。

#### 2. 打标签

论坛为用户的帖子添加标签，用于对帖子进行归类

一个图书网站可能会允许用户为自己收藏的每一本书添加标签

购物网站为自己的商品添加标签，如：”新上架“、”热销中“、”原装进口“等

#### 3. 点赞

如一条微博id作为key，field为用户id，value为用户对该微博的点赞时间戳，这样就可以查看为相同内容点赞的其他用户，以及统计相同内容收到的点赞数量。

## 有序集合 Sorted Set

有序集合的编码可以是ziplist或skiplist。

有序集合可以看做是排序的set，数据在写入有序集合中时，添加了一个score，有序集合会根据score对数据进行排序后存储，分值相同的元素，Redis会根据key按字母排序存储。

> 有序集合使用字典和跳表来实现：
>
> 字典中存储元素及其对应的分数，方便对指定成员查询其分数值，时间复杂度为O(1)
>
> 使用跳表是为了方便范围查询，如zrank、zrange等命令

### 应用场景

#### 1. 排行榜

各种实时排行榜：按照时间、播放量、点赞数等排列。

#### 2. 自动补全

由于有序集合中，相同分值的元素，Redis会对key排序后存储，利用这个特性，例如需要在最近联系人列表中自动补全，可以将输入字符串的”上一个“字符串和”下一个“字符串以相同的分值存储于最近联系人列表中，然后利用范围查询，查找到对应的以输入字符串开头的联系人集合输出，输出结果后，将插入的两个临时字符串删除即可。

#### 3. 带权重的队列

对相同类型的消息根据不同的权重设置为不同的score，然后利用倒序查询即可让重要的任务优先执行。

## HyperLongLog

Redis中实现基数统计的算法，用于统计一个包含有重复元素集合中不重复元素的个数，例如：

~~~shell
集合：{1,2,3,1,2}
该集合的基数为3
~~~

Redis中的HyperLongLog只能比较准确地估算出基数，是一个带有0.8%标准错误的近似值。

#### 命令

+ PFADD：对集合元素进行计数
+ PFCOUNT：返回集合的近似基数
+ PFMERGE：计算多个HyperLongLog的并集

### 应用场景

#### 统计UV

如果网站的流量较大，使用set来存储网站单日访问IP的话，可能会因为数据量大而导致OOM

可以使用如下命令添加对应时间的网站访问IP

~~~shell
redis> PFADD ip_20190301 "192.168.0.1" "192.168.0.2" "192.168.0.3"
~~~

使用如下命令对日活进行统计：

~~~shell 
redis> PFCOUNT ip_20190301
~~~

使用`PFMERGE`命令可以将一个月内的HyperLongLog进行合并，再使用`PFCOUNT`就可以统计月活。



